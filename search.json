[{"title":"图论例题讲解","url":"/2022/04/20/%E5%9B%BE%E8%AE%BA%E4%BE%8B%E9%A2%98%E8%AE%B2%E8%A7%A3/","content":"有机化学之神偶尔也作弊题目链接\n这个题显而易见是边双连通分量缩点和lca的综合题，思维难度不大，只不过需要一定的码量和耐心，这种考察多个算法的题一定要将程序模块化\n虽然这题题目不太严谨，它说只有碳碳单键但这道题数据里是有重边的，所以在跑tarjan时一定要判当前节点的前驱节点而不是走的那条边，lca同理\n然后您就爆切了一道紫题，太巨了%%%\n#include&lt;bits/stdc++.h&gt;using namespace std;#define MAXN 10005#define MAXM 50005#define maxlog 20namespace graph{    struct edge{        int from, to, next;    }side[MAXM*2];    int head[MAXN], ccnt = 1;    void insert(int from, int to)    {        side[++ccnt] = {from, to, head[from]}; head[from] = ccnt;        side[++ccnt] = {to, from, head[to]}; head[to] = ccnt;    }}using namespace graph;int n, m;int dfn[MAXN], low[MAXN], num;int col[MAXN], tot;bool vis[MAXN], bridge[MAXM*2];vector&lt;int&gt; mp[MAXN];int f[MAXN][21], d[MAXN];int lg[MAXN];void tarjan(int x, int pre);void paint(int x);void build(int x, int fa);int lca(int x, int y);signed main(){    cin &gt;&gt; n &gt;&gt; m;    lg[0] = -1;    for(int i = 1; i &lt;= n; i++)        lg[i] = lg[i&gt;&gt;1] + 1;    for(int i = 1; i &lt;= m; i++)    {        int a, b;        cin &gt;&gt; a &gt;&gt; b;        insert(a, b);    }    tarjan(1, 0);    for(int i = 2; i &lt;= ccnt; i++)    {        int a = side[i].from, b = side[i].to;        if(col[a] != col[b])        {            mp[col[a]].push_back(col[b]);            mp[col[a]].push_back(col[b]);        }    }    build(1, 0);    int t; cin &gt;&gt; t;    while(t --&gt; 0)    {        int a, b;        cin &gt;&gt; a &gt;&gt; b;        a = col[a], b = col[b];        int s = lca(a, b);        int ans = d[a]+d[b] - d[s]*2 + 1;        int i = maxlog;        while(!(ans&amp;(1&lt;&lt;i))) i--;        while(i &gt;= 0)        {            if(ans&amp;(1&lt;&lt;i)) cout &lt;&lt; 1;            else cout &lt;&lt; 0;            i--;        }        cout &lt;&lt; endl;    }}stack&lt;int&gt; st;void tarjan(int x, int pre){    dfn[x] = low[x] = ++num;    st.push(x);    for(int i = head[x]; i; i = side[i].next)    {        if(!dfn[side[i].to])        {            tarjan(side[i].to, x);            low[x] = min(low[side[i].to], low[x]);            if(low[side[i].to] &gt; dfn[x])                bridge[i] = bridge[i^1] = true;        }        else if(side[i].to != pre)            low[x] = min(dfn[side[i].to], low[x]);    }    if(dfn[x] == low[x])    {        ++tot;        while(st.size())        {            int a = st.top(); st.pop();            col[a] = tot;            if(a == x) break;        }    }}void paint(int x){    col[x] = tot;    for(int i = head[x]; i; i = side[i].next)        if(!bridge[i] and !col[side[i].to])            paint(side[i].to);}void build(int x, int fa){    vis[x] = true;    d[x] = d[fa]+1, f[x][0] = fa;    for(int i = 1; i &lt;= maxlog; i++)        f[x][i] = f[f[x][i-1]][i-1];        for(auto i : mp[x])        if(!vis[i]) build(i, x);}int lca(int x, int y){    if(d[x] &lt; d[y]) swap(x, y);    while(d[x] &gt; d[y])        x = f[x][lg[d[x]-d[y]]];        if(x == y) return x;    for(int i = lg[d[x]]; i &gt;= 0; i--)        if(f[x][i] != f[y][i])            x = f[x][i], y = f[y][i];    return f[x][0];}\n\n汽车加油行驶问题题目链接\n这个题是有一定思维难度的\n首先我们应按题目要求把图建好，往左或往上走要花费 , 遇到油库要花费 , 或者增设油库并加油，相当于花费 , 然后第一想法肯定是跑最短路\n但是我们发现，建完图后无法把汽车的油量体现在图里，这是我们就要去想这个油量的含义了，它其实就是在某一个点时汽车的状态，每走一条边或遇到油库时汽车状态就会发生改变，所以汽车到达同一个点时可能状态不相同，导致最后的结果也不相同\n一种解决方法是dp，dp的核心不就是状态转移吗，所以我们可以用 f[i][j][k] 来表示在  这个点时油量为  时的最小费用，然后您就可以大力讨论转移了\n当然这里讲的是图论，当然要讲图论的做法，我们发现题目中 ，汽车能装的油很少，所以我们可以把一个点拆成  个点，表示到达这个点时的剩余油量，然后  位置的第  个点向它四周的第  个点连边表示消耗  的油量，边权按照题目所给即可，最后我们跑一遍最短路，即为最终答案\n这里注意题目的坑点，一是增设油库花费 , 而增设完之后加油还要花费 , 所以一共花费 , 二是遇到油站必须加油，所以连边时注意不要多连边\n最后我们得到了分层图最短路的做法，其实这题正解是网络流，如果给多辆汽车且每个加油站次数有限制那么只能用网络流了，因为这题只有一个汽车，所以分层图最短路也可以\n您又爆切了一道紫题，太巨了%%%\n#include&lt;bits/stdc++.h&gt;using namespace std;namespace fast_IO{    #define FASTIO    #define IOSIZE 100000    char ibuf[IOSIZE], obuf[IOSIZE];    char *p1 = ibuf, *p2 = ibuf, *p3 = obuf;    #ifdef ONLINE_JUDGE        #define getchar() ((p1==p2)and(p2=(p1=ibuf)+fread(ibuf,1,IOSIZE,stdin),p1==p2)?(EOF):(*p1++))        #define putchar(x) ((p3==obuf+IOSIZE)&amp;&amp;(fwrite(obuf,p3-obuf,1,stdout),p3=obuf),*p3++=x)    #endif//fread in OJ, stdio in local        #define isdigit(ch) (ch&gt;47&amp;&amp;ch&lt;58)    #define isspace(ch) (ch&lt;33)    template&lt;typename T&gt; inline T read()    {        T s = 0; int w = 1; char ch;        while(ch=getchar(),!isdigit(ch)and(ch!=EOF)) if(ch=='-') w=-1;        if(ch == EOF) return false;        while(isdigit(ch)) s=s*10+ch-48,ch=getchar();        return s*w;    }    template&lt;typename T&gt; inline bool read(T &amp;s)    {        s = 0; int w = 1; char ch;        while(ch=getchar(),!isdigit(ch)and(ch!=EOF)) if(ch=='-') w=-1;        if(ch == EOF) return false;        while(isdigit(ch)) s=s*10+ch-48,ch=getchar();        return s*=w, true;    }    inline bool read(char &amp;s)    {        while(s = getchar(), isspace(s)&amp;&amp;(s!=EOF));        if(s == EOF) return false;        else return true;    }    inline bool read(char *s)    {        char ch;        while(ch=getchar(),isspace(ch));        if(ch == EOF) return false;        while(!isspace(ch)) *s++ = ch, ch = getchar();        *s = '\\000'; return true;    }    template&lt;typename T&gt; inline void print(T x)    {        if(x &lt; 0) putchar('-'), x = -x;        if(x &gt; 9) print(x/10);        putchar(x%10+48);    }    inline void print(char x){ putchar(x); }    inline void print(char *x){ while(*x) putchar(*x++); }    inline void print(const char *x)    { for(int i = 0; x[i]; i++) putchar(x[i]); }    #ifdef _GLIBCXX_STRING        inline bool read(std::string&amp; s)        {            s = \"\"; char ch;            while(ch=getchar(),isspace(ch));            if(ch == EOF) return false;            while(!isspace(ch)) s += ch, ch = getchar();            return true;        }        inline void print(std::string x)        {            for(int i = 0, n = x.size(); i &lt; n; i++)                putchar(x[i]);        }    #endif//string    template&lt;typename T, typename... T1&gt; inline int read(T&amp; a, T1&amp;... other){ return read(a)+read(other...); }    template&lt;typename T, typename... T1&gt; inline void print(T a, T1... other){ print(a); print(other...); }    struct Fast_IO{        ~Fast_IO(){ fwrite(obuf, p3-obuf, 1, stdout); }    }io;    template&lt;typename T&gt; Fast_IO&amp; operator &gt;&gt; (Fast_IO &amp;io, T &amp;b){ return read(b), io; }    template&lt;typename T&gt; Fast_IO&amp; operator &lt;&lt; (Fast_IO &amp;io, T b){ return print(b), io; }    #define cout io    #define cin io    #define endl '\\n'}using namespace fast_IO;#define MAXN 10005#define ll long longnamespace chain_forward_star{    struct edge{        int to, next; ll cost;    }side[MAXN*50];    int head[MAXN*11], ccnt = 1;    void insert(int from, int to, ll cost)    {        side[++ccnt] = {to, head[from], cost}; head[from] = ccnt;    }}using namespace chain_forward_star;int n, k;ll a, b, c;ll dis[MAXN*11];bool vis[MAXN*11];bool h[MAXN];int pos(int i, int j, int k)    { return (i-1)*n+j + n*n*k; }void spfa(int s);signed main(){    read(n, k, a, b, c);        for(int i = 1; i &lt;= n; i++)    for(int j = 1; j &lt;= n; j++)    {        read(h[pos(i,j,0)]);        for(int s = k; s &gt;= 1; s--)            insert(pos(i,j,s), pos(i,j,0), h[pos(i,j,0)] ? a : a+c);    }    for(int i = 1; i &lt;= n; i++)    for(int j = 1; j &lt;= n; j++)    {        int up = h[pos(i,j,0)] ? 1 : k;        for(int s = 0; s &lt; up; s++)        {            if(i-1 &gt;= 1) insert(pos(i,j,s), pos(i-1,j,s+1), b);            if(j-1 &gt;= 1) insert(pos(i,j,s), pos(i,j-1,s+1), b);            if(i+1 &lt;= n) insert(pos(i,j,s), pos(i+1,j,s+1), 0);            if(j+1 &lt;= n) insert(pos(i,j,s), pos(i,j+1,s+1), 0);        }    }    spfa(1);    ll ans = LLONG_MAX;    for(int i = 0; i &lt;= k; i++)        ans = min(ans, dis[pos(n,n,i)]);    print(ans);}void spfa(int s){    memset(dis, 0x7f, sizeof(dis));    queue&lt;int&gt; q; int x;    q.push(s); dis[s] = 0;    while(q.size())    {        x = q.front(); q.pop();        vis[x] = false;        for(int i = head[x]; i; i = side[i].next)        {            if(dis[side[i].to] &gt; dis[x] + side[i].cost)            {                dis[side[i].to] = dis[x] + side[i].cost;                if(!vis[side[i].to])                {                    q.push(side[i].to);                    vis[side[i].to] = true;                }            }        }    }}\n\n\n【模板】网络最大流这个直接看我之前写过的课件罢，当时批阅数载，增删五次写出来的还算能看\n","categories":["OI"],"tags":["114514"]},{"title":"小搜索","url":"/2022/04/20/%E5%B0%8F%E6%90%9C%E7%B4%A2/","content":"小木棍这道题说实话是个神仙题\n搜索框架很简单，这里就不细讲了，只说这题需要的优化\n\n最优性剪枝: 我们可以从小到大枚举原始木棍的长度，在找到第一个可行的长度时即是最短长度，直接结束搜索\n\n改变搜索顺序: 根据题意，短的木棍肯定比长的木棍更灵活，所以我们把木棍从大到小排序，先把难搞的拼上去，把更灵活的留给后面\n\n可行性剪枝: 这个剪枝一般是搜索剪枝的核心，这个题有好几条可行性剪枝:\n\n  ① 很明显枚举的长度  要满足 且 ,否则肯定拼不成; ② 设当前木棍长度为  , 枚举的原始木棍长度为  , 如果有长度为  的木棍, 这里只需要拼它即可，不需要考虑其他情况(留下短的都不行当然留下长的更没戏) ③ 如果当前木棍长度为  , 搜索一个分支后无解则直接返回上一层(因为当前需要新拼一根木棍，但是有一根木棍放到这里无解，那么放到后面的新木棍里一样无解)\n\n\n避免重复搜索: \n\n  ① 如果  放这里不行，那么所有等于  的木棍放这里都不行，直接跳过即可 ② 保证每一根原始木棍的拼法都是先拼大的再拼小的，即如果上一根拼的木棍为 ，则这根木棍直接从  开始枚举\n\n\n\n加上这些优化这道题就可以过了，这道题一定要自己敲一遍，因为它涵盖了所有搜索剪枝的思想(除了玄学剪枝啥的)\n#include&lt;bits/stdc++.h&gt;using namespace std;int n, sum, maxa, len;int a[105];bool dfs(int tot, int last, int now);signed main(){    cin &gt;&gt; n;    for(int i = 1, x; i &lt;= n; i++)    {        cin &gt;&gt; x;        if(x &gt; 50) continue;        a[x]++;        sum += x;        maxa = max(maxa, x);    }    for(len = maxa; len &lt;= sum/2; len++)    {        if(sum%len != 0) continue;        // cout &lt;&lt; len &lt;&lt; endl;        if(dfs(0, 114514, 0))        {            cout &lt;&lt; len &lt;&lt; endl;            return 0;        }    }    cout &lt;&lt; sum &lt;&lt; endl;    return 0;}bool dfs(int tot, int last, int now){    if(tot == n)        return now == 0;    bool ans = false;    for(int i = min({maxa, last, len-now}); i &gt;= 1; i--)    {        if(a[i] == 0)            continue;                a[i]--;        ans |= dfs(tot+1, (now+i)%len==0?114514:i, (now+i)%len);        a[i]++;        if(ans or now+i == len or now == 0)            break;    }    return ans;}\n\n靶型数独这道题其实只注意一下搜索顺序和搜索的实现暴力就可以过，但是其中有很多写搜索的技巧需要说一下\n首先，写这种限制条件比较多的题，变量名不要乱起，尽量是那种一年后再看也能直接看懂的变量名(前提是在算法竞赛中常用的风格，不要搞的像工程代码一样)\n把一些好实现但是需要一点码量的操作封装到函数里，这样在写dfs函数时思路和框架会很清晰，写搜索题时清晰的头脑很重要，适当的封装可以让你专注于某一部分的工作，debug时也会很吃香\n其次考虑优化，想想自己填数独怎么搞：肯定是  少的一行更好填，所以我们按  的数量给每一行排序，这样可以尽量减少每一层搜索树的大小\n具体可以看看我的代码，这算是我写的比较好看的一道题了\n#include&lt;bits/stdc++.h&gt;using namespace std;struct node{    int id, tot;};node line[15];int ans = -1; int a[15][15];bool l[15][15], c[15][15], b[15][15];void dfs(int x, int y);int block(int x, int y);bool cant(int x, int y, int val);void sign(int x, int y, int val, bool flag);int getscore();signed main(){    for(int i = 1; i &lt;= 9; i++)    {        line[i].id = i;        for(int j = 1; j &lt;= 9; j++)        {            int x; cin &gt;&gt; x;            if(x == 0) continue;            sign(i, j, x, true);            line[i].tot++;        }    }    sort(line+1, line+10, [](node a, node b){        return a.tot &gt; b.tot;    });    dfs(1, 1);    cout &lt;&lt; ans &lt;&lt; endl;}void dfs(int xx, int yy){    int x = line[xx].id, y = yy;    if(xx == 9 and y == 10)    {        ans = max(ans, getscore());        return void();    }    if(yy == 10) return dfs(xx+1, 1);    if(a[x][y] != 0) return dfs(xx, yy+1);    for(int i = 1; i &lt;= 9; i++)    {        if(cant(x, y, i))            continue;        sign(x, y, i, true);        dfs(xx, yy+1);        sign(x, y, i, false);    }}int block(int x, int y){    return (x-1)/3*3 + (y-1)/3 + 1;}bool cant(int x, int y, int val){    return l[x][val] or c[y][val] or b[block(x,y)][val];}void sign(int x, int y, int val, bool flag){    l[x][val] = flag;    c[y][val] = flag;    b[block(x,y)][val] = flag;    a[x][y] = flag ? val : 0;}int getscore(){    int sum = 0;    for(int i = 1; i &lt;= 9; i++)    for(int j = 1; j &lt;= 9; j++)    {        if(i == 1 or j == 1 or i == 9 or j == 9)            sum += a[i][j]*6;        else if(i == 2 or j == 2 or i == 8 or j == 8)            sum += a[i][j]*7;        else if(i == 3 or j == 3 or i == 7 or j == 7)            sum += a[i][j]*8;        else if(i == 4 or j == 4 or i == 6 or j == 6)            sum += a[i][j]*9;        else            sum += a[i][j]*10;    }    return sum;}\n\n斗地主这种题目很长、操作很多的题，搜索的实现肯定不会很简单，所以可以先画一个大概的流程图，明确搜索顺序，在写程序的时候可以边写边注释\n这里注意搜索的实现方式，一定要写的简单但是不要太过冗余\n这道题需要最优性剪枝: 记录历史最佳答案，如果当前搜索的答案大于这个历史最佳就直接return就好了\n针对这个题目有一个技巧：每种牌可以出1,2,3,4张，也就是一次能将一种牌打光，所以我们可以先搜牌型的出法，然后一次把剩下牌全打光，一定不要去搜单和对怎么出，怎么搜怎么炸(自己算算组合数就知道这玩意多大了)\n#include&lt;bits/stdc++.h&gt;using namespace std;int n, ans;int card[20];void work();int to_num(string a);void dfs(int d);bool check();signed main(){    int t;    cin &gt;&gt; t &gt;&gt; n;    for(int i = 1; i &lt;= t; i++)        work();}void work(){    memset(card, 0, sizeof(card));    for(int i = 1; i &lt;= n; i++)    {        string a, b;        cin &gt;&gt; a &gt;&gt; b;        if(a == \"1\") card[14]++;        else if(a == \"0\" and b == \"1\") card[15]++;        else if(a == \"0\" and b == \"2\") card[16]++;        else card[to_num(a)]++;    }    ans = INT_MAX;    dfs(0);    cout &lt;&lt; ans &lt;&lt; endl;}void dfs(int step){    if(step &gt;= ans)        return void();    //单顺子    for(int l = 3; l &lt;= 14; l++)    {        int r = l-1;        while(card[r+1] &gt;= 1 and r &lt; 14)            r++;        if(r-l+1 &lt; 5)            continue;        for(int i = l; i &lt;= r; i++)        {            card[i] -= 1;            if(i-l+1 &lt; 5) continue;            dfs(step+1);        }        for(int i = l; i &lt;= r; i++)            card[i] += 1;    }    //双顺子    for(int l = 3; l &lt;= 14; l++)    {        int r = l-1;        while(card[r+1] &gt;= 2 and r &lt; 14)            r++;        if(r-l+1 &lt; 3)            continue;        for(int i = l; i &lt;= r; i++)        {            card[i] -= 2;            if(i-l+1 &lt; 3) continue;            dfs(step+1);        }        for(int i = l; i &lt;= r; i++)            card[i] += 2;    }    //三顺子    for(int l = 3; l &lt;= 14; l++)    {        int r = l-1;        while(card[r+1] &gt;= 3 and r &lt; 14)            r++;        if(r-l+1 &lt; 2)            continue;        for(int i = l; i &lt;= r; i++)        {            card[i] -= 3;            if(i-l+1 &lt; 2) continue;            dfs(step+1);        }        for(int i = l; i &lt;= r; i++)            card[i] += 3;    }    //四带    for(int i = 2; i &lt;= 14; i++)    {        if(card[i] &lt; 4) continue;        card[i] -= 4;        dfs(step+1);        for(int len = 1; len &lt;= 2; len++)        {            for(int d1 = 2; d1 &lt;= 16; d1++)            {                for(int d2 = 2; d2 &lt;= 16; d2++)                {                    if(card[d1] &lt; len or card[d2] &lt; len)                        continue;                                        card[d1] -= len;                    card[d2] -= len;                    dfs(step+1);                    card[d1] += len;                    card[d2] += len;                }            }        }        card[i] += 4;    }    //三带    for(int i = 2; i &lt;= 14; i++)    {        if(card[i] &lt; 3) continue;        card[i] -= 3;        for(int len = 1; len &lt;= 2; len++)        {            for(int d = 2; d &lt;= 16; d++)            {                if(card[d] &lt; len)                    continue;                card[d] -= len;                dfs(step+1);                card[d] += len;            }        }        card[i] += 3;    }    for(int i = 2; i &lt;= 14; i++)        if(card[i] != 0) step++;    if(card[15] or card[16]) step++;    ans = min(ans, step);}bool check(){    for(int i = 2; i &lt;= 16; i++)        if(card[i] != 0)            return false;    return true;}int to_num(string a){    int s = 0;    for(auto i : a)        s = s*10 + i-'0';    return s;}","categories":["OI"],"tags":["114514"]}]