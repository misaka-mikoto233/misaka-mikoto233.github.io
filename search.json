[{"title":"图论例题讲解","url":"/2022/04/20/%E5%9B%BE%E8%AE%BA%E4%BE%8B%E9%A2%98%E8%AE%B2%E8%A7%A3/","content":"大陆争霸题目链接\n大致题意： 给定一个图，每个节点间有一些单向附加边，到达一个节点后它连出去的附加边全部删去，只有一个节点没有附加边连入时才可进入，求  到  的最短路\n首先这题没有负边权直接用 dijkstra 算法即可解决，唯一不同的是怎么解决这个附加边问题，因为这个附加边是单向边，且题目保证无环，那么就可以类比拓扑排序了\n记 in[i] 为第  个节点附加边的入度，则当 in[i] == 0 时才可进入这个点，所以我们跑最短路时要判断下一个点是否入度为 , 只有当入度为  时才可以更新这个点的最短路，具体实现方法其实就是拓扑排序和dij一起写到代码里即可\n排序题目链接\n题意就是给你一些大小关系，求最少需要多少对关系可以确定大小顺序或找出矛盾\n很明显大小关系具有传递性，所以对于 ，我们可以从  向  连一条有向边，如果有环即为矛盾，如果此图拓扑排序时每一层都只有一个点，且所有点都出现过，即为确定了大小顺序\n狡猾的商人题目链接\n这题很明显是一个差分约束\n记 sum[i] 为 第  个月到第  个月的收支总和，题目中给的 从第  个月到第  个月的总收入为  就可以写为 sum[t]-sum[s-1] = v , 将其拆成两个不等式建立差分约束系统即可，若有负环则该差分约束系统无解\n有机化学之神偶尔也作弊题目链接\n这个题显而易见是边双连通分量缩点和lca的综合题，思维难度不大\n虽然这题题目不太严谨，它说只有碳碳单键但这道题数据里是有重边的(两个碳连了两个碳碳单键)，所以做题时不要太相信题目背景中的描述，即使明确给出限制条件也要考虑进去(比赛题又不是没出过数据问题)\n首先用 tarjan 算法处理出桥边，把桥边删去后每一个连通块都是一个边双连通分量，可以直接遍历一遍将连通块染色，遍历时不走桥边，即可处理出边双连通分量，缩点之后，原图的桥即为缩点后的图的边\n因为缩完点的图一定没有环，所以缩完点后就是一棵树(题目保证联通，不连通则为森林)，求两点间距离可以用lca解决\n汽车加油行驶问题题目链接\n这个题是有一定思维难度的\n首先我们应按题目要求把图建好，往左或往上走要花费 , 遇到油库要花费 , 或者增设油库并加油，相当于花费 , 然后第一想法肯定是跑最短路\n但是我们发现，建完图后无法把汽车的油量体现在图里，这是我们就要去想这个油量的含义了，它其实就是在某一个点时汽车的状态，每走一条边或遇到油库时汽车状态就会发生改变，所以汽车到达同一个点时可能状态不相同，导致最后的结果也不相同\n一种解决方法是dp，dp的核心不就是状态转移吗，所以我们可以用 f[i][j][k] 来表示在  这个点时油量为  时的最小费用，然后您就可以大力讨论转移了\n当然这里讲的是图论，当然要讲图论的做法，我们发现题目中 ，汽车能装的油很少，所以我们可以把一个点拆成  个点，表示到达这个点时的剩余油量，然后  位置的第  个点向它四周的第  个点连边表示消耗  的油量，边权按照题目所给即可，最后我们跑一遍最短路，即为最终答案\n这里注意题目的坑点，一是增设油库花费 , 而增设完之后加油还要花费 , 所以一共花费 , 二是遇到油站必须加油，所以连边时注意不要多连边\n最后我们得到了分层图最短路的做法，其实这题正解是网络流，如果汽车很多且每个加油站次数有限制那么只能用网络流了，因为这题只有一个汽车，所以分层图最短路也可以\n【模板】网络最大流这个直接看我之前写过的课件罢，当时批阅数载，增删五次写出来的还算能看\n","categories":["OI"],"tags":["114514"]},{"title":"小搜索","url":"/2022/04/20/%E5%B0%8F%E6%90%9C%E7%B4%A2/","content":"小木棍这道题说实话是个神仙题\n搜索框架很简单，这里就不细讲了，只说这题需要的优化\n\n最优性剪枝: 我们可以从小到大枚举原始木棍的长度，在找到第一个可行的长度时即是最短长度，直接结束搜索\n\n改变搜索顺序: 根据题意，短的木棍肯定比长的木棍更灵活，所以我们把木棍从大到小排序，先把难搞的拼上去，把更灵活的留给后面\n\n可行性剪枝: 这个剪枝一般是搜索剪枝的核心，这个题有好几条可行性剪枝:\n\n  ① 很明显枚举的长度  要满足 且 ,否则肯定拼不成; ② 设当前木棍长度为  , 枚举的原始木棍长度为  , 如果有长度为  的木棍, 这里只需要拼它即可，不需要考虑其他情况(留下短的都不行当然留下长的更没戏) ③ 如果当前木棍长度为  , 搜索一个分支后无解则直接返回上一层(因为当前需要新拼一根木棍，但是有一根木棍放到这里无解，那么放到后面的新木棍里一样无解)\n\n\n避免重复搜索: \n\n  ① 如果  放这里不行，那么所有等于  的木棍放这里都不行，直接跳过即可 ② 保证每一根原始木棍的拼法都是先拼大的再拼小的，即如果上一根拼的木棍为 ，则这根木棍直接从  开始枚举\n\n\n\n加上这些优化这道题就可以过了，这道题一定要自己敲一遍，因为它涵盖了所有搜索剪枝的思想(除了玄学剪枝啥的)\n#include&lt;bits/stdc++.h&gt;using namespace std;int n, sum, maxa, len;int a[105];bool dfs(int tot, int last, int now);signed main(){    cin &gt;&gt; n;    for(int i = 1, x; i &lt;= n; i++)    {        cin &gt;&gt; x;        if(x &gt; 50) continue;        a[x]++;        sum += x;        maxa = max(maxa, x);    }    for(len = maxa; len &lt;= sum/2; len++)    {        if(sum%len != 0) continue;        // cout &lt;&lt; len &lt;&lt; endl;        if(dfs(0, 114514, 0))        {            cout &lt;&lt; len &lt;&lt; endl;            return 0;        }    }    cout &lt;&lt; sum &lt;&lt; endl;    return 0;}bool dfs(int tot, int last, int now){    if(tot == n)        return now == 0;    bool ans = false;    for(int i = min({maxa, last, len-now}); i &gt;= 1; i--)    {        if(a[i] == 0)            continue;                a[i]--;        ans |= dfs(tot+1, (now+i)%len==0?114514:i, (now+i)%len);        a[i]++;        if(ans or now+i == len or now == 0)            break;    }    return ans;}\n\n靶型数独这道题其实只注意一下搜索顺序和搜索的实现暴力就可以过，但是其中有很多写搜索的技巧需要说一下\n首先，写这种限制条件比较多的题，变量名不要乱起，尽量是那种一年后再看也能直接看懂的变量名(前提是在算法竞赛中常用的风格，不要搞的像工程代码一样)\n把一些好实现但是需要一点码量的操作封装到函数里，这样在写dfs函数时思路和框架会很清晰，写搜索题时清晰的头脑很重要，适当的封装可以让你专注于某一部分的工作，debug时也会很吃香\n其次考虑优化，想想自己填数独怎么搞：肯定是  少的一行更好填，所以我们按  的数量给每一行排序，这样可以尽量减少每一层搜索树的大小\n具体可以看看我的代码，这算是我写的比较好看的一道题了\n#include&lt;bits/stdc++.h&gt;using namespace std;struct node{    int id, tot;};node line[15];int ans = -1; int a[15][15];bool l[15][15], c[15][15], b[15][15];void dfs(int x, int y);int block(int x, int y);bool cant(int x, int y, int val);void sign(int x, int y, int val, bool flag);int getscore();signed main(){    for(int i = 1; i &lt;= 9; i++)    {        line[i].id = i;        for(int j = 1; j &lt;= 9; j++)        {            int x; cin &gt;&gt; x;            if(x == 0) continue;            sign(i, j, x, true);            line[i].tot++;        }    }    sort(line+1, line+10, [](node a, node b){        return a.tot &gt; b.tot;    });    dfs(1, 1);    cout &lt;&lt; ans &lt;&lt; endl;}void dfs(int xx, int yy){    int x = line[xx].id, y = yy;    if(xx == 9 and y == 10)    {        ans = max(ans, getscore());        return void();    }    if(yy == 10) return dfs(xx+1, 1);    if(a[x][y] != 0) return dfs(xx, yy+1);    for(int i = 1; i &lt;= 9; i++)    {        if(cant(x, y, i))            continue;        sign(x, y, i, true);        dfs(xx, yy+1);        sign(x, y, i, false);    }}int block(int x, int y){    return (x-1)/3*3 + (y-1)/3 + 1;}bool cant(int x, int y, int val){    return l[x][val] or c[y][val] or b[block(x,y)][val];}void sign(int x, int y, int val, bool flag){    l[x][val] = flag;    c[y][val] = flag;    b[block(x,y)][val] = flag;    a[x][y] = flag ? val : 0;}int getscore(){    int sum = 0;    for(int i = 1; i &lt;= 9; i++)    for(int j = 1; j &lt;= 9; j++)    {        if(i == 1 or j == 1 or i == 9 or j == 9)            sum += a[i][j]*6;        else if(i == 2 or j == 2 or i == 8 or j == 8)            sum += a[i][j]*7;        else if(i == 3 or j == 3 or i == 7 or j == 7)            sum += a[i][j]*8;        else if(i == 4 or j == 4 or i == 6 or j == 6)            sum += a[i][j]*9;        else            sum += a[i][j]*10;    }    return sum;}\n\n斗地主这种题目很长、操作很多的题，搜索的实现肯定不会很简单，所以可以先画一个大概的流程图，明确搜索顺序，在写程序的时候可以边写边注释\n这里注意搜索的实现方式，一定要写的简单但是不要太过冗余\n这道题需要最优性剪枝: 记录历史最佳答案，如果当前搜索的答案大于这个历史最佳就直接return就好了\n针对这个题目有一个技巧：每种牌可以出1,2,3,4张，也就是一次能将一种牌打光，所以我们可以先搜牌型的出法，然后一次把剩下牌全打光，一定不要去搜单和对怎么出，怎么搜怎么炸(自己算算组合数就知道这玩意多大了)\n#include&lt;bits/stdc++.h&gt;using namespace std;int n, ans;int card[20];void work();int to_num(string a);void dfs(int d);bool check();signed main(){    int t;    cin &gt;&gt; t &gt;&gt; n;    for(int i = 1; i &lt;= t; i++)        work();}void work(){    memset(card, 0, sizeof(card));    for(int i = 1; i &lt;= n; i++)    {        string a, b;        cin &gt;&gt; a &gt;&gt; b;        if(a == \"1\") card[14]++;        else if(a == \"0\" and b == \"1\") card[15]++;        else if(a == \"0\" and b == \"2\") card[16]++;        else card[to_num(a)]++;    }    ans = INT_MAX;    dfs(0);    cout &lt;&lt; ans &lt;&lt; endl;}void dfs(int step){    if(step &gt;= ans)        return void();    //单顺子    for(int l = 3; l &lt;= 14; l++)    {        int r = l-1;        while(card[r+1] &gt;= 1 and r &lt; 14)            r++;        if(r-l+1 &lt; 5)            continue;        for(int i = l; i &lt;= r; i++)        {            card[i] -= 1;            if(i-l+1 &lt; 5) continue;            dfs(step+1);        }        for(int i = l; i &lt;= r; i++)            card[i] += 1;    }    //双顺子    for(int l = 3; l &lt;= 14; l++)    {        int r = l-1;        while(card[r+1] &gt;= 2 and r &lt; 14)            r++;        if(r-l+1 &lt; 3)            continue;        for(int i = l; i &lt;= r; i++)        {            card[i] -= 2;            if(i-l+1 &lt; 3) continue;            dfs(step+1);        }        for(int i = l; i &lt;= r; i++)            card[i] += 2;    }    //三顺子    for(int l = 3; l &lt;= 14; l++)    {        int r = l-1;        while(card[r+1] &gt;= 3 and r &lt; 14)            r++;        if(r-l+1 &lt; 2)            continue;        for(int i = l; i &lt;= r; i++)        {            card[i] -= 3;            if(i-l+1 &lt; 2) continue;            dfs(step+1);        }        for(int i = l; i &lt;= r; i++)            card[i] += 3;    }    //四带    for(int i = 2; i &lt;= 14; i++)    {        if(card[i] &lt; 4) continue;        card[i] -= 4;        dfs(step+1);        for(int len = 1; len &lt;= 2; len++)        {            for(int d1 = 2; d1 &lt;= 16; d1++)            {                for(int d2 = 2; d2 &lt;= 16; d2++)                {                    if(card[d1] &lt; len or card[d2] &lt; len)                        continue;                                        card[d1] -= len;                    card[d2] -= len;                    dfs(step+1);                    card[d1] += len;                    card[d2] += len;                }            }        }        card[i] += 4;    }    //三带    for(int i = 2; i &lt;= 14; i++)    {        if(card[i] &lt; 3) continue;        card[i] -= 3;        for(int len = 1; len &lt;= 2; len++)        {            for(int d = 2; d &lt;= 16; d++)            {                if(card[d] &lt; len)                    continue;                card[d] -= len;                dfs(step+1);                card[d] += len;            }        }        card[i] += 3;    }    for(int i = 2; i &lt;= 14; i++)        if(card[i] != 0) step++;    if(card[15] or card[16]) step++;    ans = min(ans, step);}bool check(){    for(int i = 2; i &lt;= 16; i++)        if(card[i] != 0)            return false;    return true;}int to_num(string a){    int s = 0;    for(auto i : a)        s = s*10 + i-'0';    return s;}","categories":["OI"],"tags":["114514"]}]